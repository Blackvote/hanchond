// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package cosmos

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
	time "time"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson31c5d66DecodeGithubComHanchonHanchondLibTypesCosmos(in *jlexer.Lexer, out *CosmosBlockResult) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "block_id":
			easyjson31c5d66Decode(in, &out.BlockID)
		case "block":
			easyjson31c5d66Decode1(in, &out.Block)
		case "pagination":
			easyjson31c5d66Decode2(in, &out.Pagination)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66EncodeGithubComHanchonHanchondLibTypesCosmos(out *jwriter.Writer, in CosmosBlockResult) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"block_id\":"
		out.RawString(prefix[1:])
		easyjson31c5d66Encode(out, in.BlockID)
	}
	{
		const prefix string = ",\"block\":"
		out.RawString(prefix)
		easyjson31c5d66Encode1(out, in.Block)
	}
	{
		const prefix string = ",\"pagination\":"
		out.RawString(prefix)
		easyjson31c5d66Encode2(out, in.Pagination)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v CosmosBlockResult) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson31c5d66EncodeGithubComHanchonHanchondLibTypesCosmos(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v CosmosBlockResult) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson31c5d66EncodeGithubComHanchonHanchondLibTypesCosmos(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *CosmosBlockResult) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson31c5d66DecodeGithubComHanchonHanchondLibTypesCosmos(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *CosmosBlockResult) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson31c5d66DecodeGithubComHanchonHanchondLibTypesCosmos(l, v)
}
func easyjson31c5d66Decode2(in *jlexer.Lexer, out *struct {
	NextKey interface{} `json:"next_key"`
	Total   string      `json:"total"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "next_key":
			if m, ok := out.NextKey.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.NextKey.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.NextKey = in.Interface()
			}
		case "total":
			out.Total = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode2(out *jwriter.Writer, in struct {
	NextKey interface{} `json:"next_key"`
	Total   string      `json:"total"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"next_key\":"
		out.RawString(prefix[1:])
		if m, ok := in.NextKey.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.NextKey.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.NextKey))
		}
	}
	{
		const prefix string = ",\"total\":"
		out.RawString(prefix)
		out.String(string(in.Total))
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode1(in *jlexer.Lexer, out *struct {
	Header struct {
		Version struct {
			Block string `json:"block"`
			App   string `json:"app"`
		} `json:"version"`
		ChainID     string    `json:"chain_id"`
		Height      string    `json:"height"`
		Time        time.Time `json:"time"`
		LastBlockID struct {
			Hash          string `json:"hash"`
			PartSetHeader struct {
				Total int    `json:"total"`
				Hash  string `json:"hash"`
			} `json:"part_set_header"`
		} `json:"last_block_id"`
		LastCommitHash     string `json:"last_commit_hash"`
		DataHash           string `json:"data_hash"`
		ValidatorsHash     string `json:"validators_hash"`
		NextValidatorsHash string `json:"next_validators_hash"`
		ConsensusHash      string `json:"consensus_hash"`
		AppHash            string `json:"app_hash"`
		LastResultsHash    string `json:"last_results_hash"`
		EvidenceHash       string `json:"evidence_hash"`
		ProposerAddress    string `json:"proposer_address"`
	} `json:"header"`
	Data struct {
		Txs []string `json:"txs"`
	} `json:"data"`
	Evidence struct {
		Evidence []interface{} `json:"evidence"`
	} `json:"evidence"`
	LastCommit struct {
		Height  string `json:"height"`
		Round   int    `json:"round"`
		BlockID struct {
			Hash          string `json:"hash"`
			PartSetHeader struct {
				Total int    `json:"total"`
				Hash  string `json:"hash"`
			} `json:"part_set_header"`
		} `json:"block_id"`
		Signatures []struct {
			BlockIDFlag      string    `json:"block_id_flag"`
			ValidatorAddress string    `json:"validator_address"`
			Timestamp        time.Time `json:"timestamp"`
			Signature        string    `json:"signature"`
		} `json:"signatures"`
	} `json:"last_commit"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "header":
			easyjson31c5d66Decode3(in, &out.Header)
		case "data":
			easyjson31c5d66Decode4(in, &out.Data)
		case "evidence":
			easyjson31c5d66Decode5(in, &out.Evidence)
		case "last_commit":
			easyjson31c5d66Decode6(in, &out.LastCommit)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode1(out *jwriter.Writer, in struct {
	Header struct {
		Version struct {
			Block string `json:"block"`
			App   string `json:"app"`
		} `json:"version"`
		ChainID     string    `json:"chain_id"`
		Height      string    `json:"height"`
		Time        time.Time `json:"time"`
		LastBlockID struct {
			Hash          string `json:"hash"`
			PartSetHeader struct {
				Total int    `json:"total"`
				Hash  string `json:"hash"`
			} `json:"part_set_header"`
		} `json:"last_block_id"`
		LastCommitHash     string `json:"last_commit_hash"`
		DataHash           string `json:"data_hash"`
		ValidatorsHash     string `json:"validators_hash"`
		NextValidatorsHash string `json:"next_validators_hash"`
		ConsensusHash      string `json:"consensus_hash"`
		AppHash            string `json:"app_hash"`
		LastResultsHash    string `json:"last_results_hash"`
		EvidenceHash       string `json:"evidence_hash"`
		ProposerAddress    string `json:"proposer_address"`
	} `json:"header"`
	Data struct {
		Txs []string `json:"txs"`
	} `json:"data"`
	Evidence struct {
		Evidence []interface{} `json:"evidence"`
	} `json:"evidence"`
	LastCommit struct {
		Height  string `json:"height"`
		Round   int    `json:"round"`
		BlockID struct {
			Hash          string `json:"hash"`
			PartSetHeader struct {
				Total int    `json:"total"`
				Hash  string `json:"hash"`
			} `json:"part_set_header"`
		} `json:"block_id"`
		Signatures []struct {
			BlockIDFlag      string    `json:"block_id_flag"`
			ValidatorAddress string    `json:"validator_address"`
			Timestamp        time.Time `json:"timestamp"`
			Signature        string    `json:"signature"`
		} `json:"signatures"`
	} `json:"last_commit"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"header\":"
		out.RawString(prefix[1:])
		easyjson31c5d66Encode3(out, in.Header)
	}
	{
		const prefix string = ",\"data\":"
		out.RawString(prefix)
		easyjson31c5d66Encode4(out, in.Data)
	}
	{
		const prefix string = ",\"evidence\":"
		out.RawString(prefix)
		easyjson31c5d66Encode5(out, in.Evidence)
	}
	{
		const prefix string = ",\"last_commit\":"
		out.RawString(prefix)
		easyjson31c5d66Encode6(out, in.LastCommit)
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode6(in *jlexer.Lexer, out *struct {
	Height  string `json:"height"`
	Round   int    `json:"round"`
	BlockID struct {
		Hash          string `json:"hash"`
		PartSetHeader struct {
			Total int    `json:"total"`
			Hash  string `json:"hash"`
		} `json:"part_set_header"`
	} `json:"block_id"`
	Signatures []struct {
		BlockIDFlag      string    `json:"block_id_flag"`
		ValidatorAddress string    `json:"validator_address"`
		Timestamp        time.Time `json:"timestamp"`
		Signature        string    `json:"signature"`
	} `json:"signatures"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "height":
			out.Height = string(in.String())
		case "round":
			out.Round = int(in.Int())
		case "block_id":
			easyjson31c5d66Decode(in, &out.BlockID)
		case "signatures":
			if in.IsNull() {
				in.Skip()
				out.Signatures = nil
			} else {
				in.Delim('[')
				if out.Signatures == nil {
					if !in.IsDelim(']') {
						out.Signatures = make([]struct {
							BlockIDFlag      string    `json:"block_id_flag"`
							ValidatorAddress string    `json:"validator_address"`
							Timestamp        time.Time `json:"timestamp"`
							Signature        string    `json:"signature"`
						}, 0, 0)
					} else {
						out.Signatures = []struct {
							BlockIDFlag      string    `json:"block_id_flag"`
							ValidatorAddress string    `json:"validator_address"`
							Timestamp        time.Time `json:"timestamp"`
							Signature        string    `json:"signature"`
						}{}
					}
				} else {
					out.Signatures = (out.Signatures)[:0]
				}
				for !in.IsDelim(']') {
					var v1 struct {
						BlockIDFlag      string    `json:"block_id_flag"`
						ValidatorAddress string    `json:"validator_address"`
						Timestamp        time.Time `json:"timestamp"`
						Signature        string    `json:"signature"`
					}
					easyjson31c5d66Decode7(in, &v1)
					out.Signatures = append(out.Signatures, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode6(out *jwriter.Writer, in struct {
	Height  string `json:"height"`
	Round   int    `json:"round"`
	BlockID struct {
		Hash          string `json:"hash"`
		PartSetHeader struct {
			Total int    `json:"total"`
			Hash  string `json:"hash"`
		} `json:"part_set_header"`
	} `json:"block_id"`
	Signatures []struct {
		BlockIDFlag      string    `json:"block_id_flag"`
		ValidatorAddress string    `json:"validator_address"`
		Timestamp        time.Time `json:"timestamp"`
		Signature        string    `json:"signature"`
	} `json:"signatures"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"height\":"
		out.RawString(prefix[1:])
		out.String(string(in.Height))
	}
	{
		const prefix string = ",\"round\":"
		out.RawString(prefix)
		out.Int(int(in.Round))
	}
	{
		const prefix string = ",\"block_id\":"
		out.RawString(prefix)
		easyjson31c5d66Encode(out, in.BlockID)
	}
	{
		const prefix string = ",\"signatures\":"
		out.RawString(prefix)
		if in.Signatures == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Signatures {
				if v2 > 0 {
					out.RawByte(',')
				}
				easyjson31c5d66Encode7(out, v3)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode7(in *jlexer.Lexer, out *struct {
	BlockIDFlag      string    `json:"block_id_flag"`
	ValidatorAddress string    `json:"validator_address"`
	Timestamp        time.Time `json:"timestamp"`
	Signature        string    `json:"signature"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "block_id_flag":
			out.BlockIDFlag = string(in.String())
		case "validator_address":
			out.ValidatorAddress = string(in.String())
		case "timestamp":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Timestamp).UnmarshalJSON(data))
			}
		case "signature":
			out.Signature = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode7(out *jwriter.Writer, in struct {
	BlockIDFlag      string    `json:"block_id_flag"`
	ValidatorAddress string    `json:"validator_address"`
	Timestamp        time.Time `json:"timestamp"`
	Signature        string    `json:"signature"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"block_id_flag\":"
		out.RawString(prefix[1:])
		out.String(string(in.BlockIDFlag))
	}
	{
		const prefix string = ",\"validator_address\":"
		out.RawString(prefix)
		out.String(string(in.ValidatorAddress))
	}
	{
		const prefix string = ",\"timestamp\":"
		out.RawString(prefix)
		out.Raw((in.Timestamp).MarshalJSON())
	}
	{
		const prefix string = ",\"signature\":"
		out.RawString(prefix)
		out.String(string(in.Signature))
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode5(in *jlexer.Lexer, out *struct {
	Evidence []interface{} `json:"evidence"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "evidence":
			if in.IsNull() {
				in.Skip()
				out.Evidence = nil
			} else {
				in.Delim('[')
				if out.Evidence == nil {
					if !in.IsDelim(']') {
						out.Evidence = make([]interface{}, 0, 4)
					} else {
						out.Evidence = []interface{}{}
					}
				} else {
					out.Evidence = (out.Evidence)[:0]
				}
				for !in.IsDelim(']') {
					var v4 interface{}
					if m, ok := v4.(easyjson.Unmarshaler); ok {
						m.UnmarshalEasyJSON(in)
					} else if m, ok := v4.(json.Unmarshaler); ok {
						_ = m.UnmarshalJSON(in.Raw())
					} else {
						v4 = in.Interface()
					}
					out.Evidence = append(out.Evidence, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode5(out *jwriter.Writer, in struct {
	Evidence []interface{} `json:"evidence"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"evidence\":"
		out.RawString(prefix[1:])
		if in.Evidence == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v5, v6 := range in.Evidence {
				if v5 > 0 {
					out.RawByte(',')
				}
				if m, ok := v6.(easyjson.Marshaler); ok {
					m.MarshalEasyJSON(out)
				} else if m, ok := v6.(json.Marshaler); ok {
					out.Raw(m.MarshalJSON())
				} else {
					out.Raw(json.Marshal(v6))
				}
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode4(in *jlexer.Lexer, out *struct {
	Txs []string `json:"txs"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "txs":
			if in.IsNull() {
				in.Skip()
				out.Txs = nil
			} else {
				in.Delim('[')
				if out.Txs == nil {
					if !in.IsDelim(']') {
						out.Txs = make([]string, 0, 4)
					} else {
						out.Txs = []string{}
					}
				} else {
					out.Txs = (out.Txs)[:0]
				}
				for !in.IsDelim(']') {
					var v7 string
					v7 = string(in.String())
					out.Txs = append(out.Txs, v7)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode4(out *jwriter.Writer, in struct {
	Txs []string `json:"txs"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"txs\":"
		out.RawString(prefix[1:])
		if in.Txs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Txs {
				if v8 > 0 {
					out.RawByte(',')
				}
				out.String(string(v9))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode3(in *jlexer.Lexer, out *struct {
	Version struct {
		Block string `json:"block"`
		App   string `json:"app"`
	} `json:"version"`
	ChainID     string    `json:"chain_id"`
	Height      string    `json:"height"`
	Time        time.Time `json:"time"`
	LastBlockID struct {
		Hash          string `json:"hash"`
		PartSetHeader struct {
			Total int    `json:"total"`
			Hash  string `json:"hash"`
		} `json:"part_set_header"`
	} `json:"last_block_id"`
	LastCommitHash     string `json:"last_commit_hash"`
	DataHash           string `json:"data_hash"`
	ValidatorsHash     string `json:"validators_hash"`
	NextValidatorsHash string `json:"next_validators_hash"`
	ConsensusHash      string `json:"consensus_hash"`
	AppHash            string `json:"app_hash"`
	LastResultsHash    string `json:"last_results_hash"`
	EvidenceHash       string `json:"evidence_hash"`
	ProposerAddress    string `json:"proposer_address"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "version":
			easyjson31c5d66Decode8(in, &out.Version)
		case "chain_id":
			out.ChainID = string(in.String())
		case "height":
			out.Height = string(in.String())
		case "time":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.Time).UnmarshalJSON(data))
			}
		case "last_block_id":
			easyjson31c5d66Decode(in, &out.LastBlockID)
		case "last_commit_hash":
			out.LastCommitHash = string(in.String())
		case "data_hash":
			out.DataHash = string(in.String())
		case "validators_hash":
			out.ValidatorsHash = string(in.String())
		case "next_validators_hash":
			out.NextValidatorsHash = string(in.String())
		case "consensus_hash":
			out.ConsensusHash = string(in.String())
		case "app_hash":
			out.AppHash = string(in.String())
		case "last_results_hash":
			out.LastResultsHash = string(in.String())
		case "evidence_hash":
			out.EvidenceHash = string(in.String())
		case "proposer_address":
			out.ProposerAddress = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode3(out *jwriter.Writer, in struct {
	Version struct {
		Block string `json:"block"`
		App   string `json:"app"`
	} `json:"version"`
	ChainID     string    `json:"chain_id"`
	Height      string    `json:"height"`
	Time        time.Time `json:"time"`
	LastBlockID struct {
		Hash          string `json:"hash"`
		PartSetHeader struct {
			Total int    `json:"total"`
			Hash  string `json:"hash"`
		} `json:"part_set_header"`
	} `json:"last_block_id"`
	LastCommitHash     string `json:"last_commit_hash"`
	DataHash           string `json:"data_hash"`
	ValidatorsHash     string `json:"validators_hash"`
	NextValidatorsHash string `json:"next_validators_hash"`
	ConsensusHash      string `json:"consensus_hash"`
	AppHash            string `json:"app_hash"`
	LastResultsHash    string `json:"last_results_hash"`
	EvidenceHash       string `json:"evidence_hash"`
	ProposerAddress    string `json:"proposer_address"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix[1:])
		easyjson31c5d66Encode8(out, in.Version)
	}
	{
		const prefix string = ",\"chain_id\":"
		out.RawString(prefix)
		out.String(string(in.ChainID))
	}
	{
		const prefix string = ",\"height\":"
		out.RawString(prefix)
		out.String(string(in.Height))
	}
	{
		const prefix string = ",\"time\":"
		out.RawString(prefix)
		out.Raw((in.Time).MarshalJSON())
	}
	{
		const prefix string = ",\"last_block_id\":"
		out.RawString(prefix)
		easyjson31c5d66Encode(out, in.LastBlockID)
	}
	{
		const prefix string = ",\"last_commit_hash\":"
		out.RawString(prefix)
		out.String(string(in.LastCommitHash))
	}
	{
		const prefix string = ",\"data_hash\":"
		out.RawString(prefix)
		out.String(string(in.DataHash))
	}
	{
		const prefix string = ",\"validators_hash\":"
		out.RawString(prefix)
		out.String(string(in.ValidatorsHash))
	}
	{
		const prefix string = ",\"next_validators_hash\":"
		out.RawString(prefix)
		out.String(string(in.NextValidatorsHash))
	}
	{
		const prefix string = ",\"consensus_hash\":"
		out.RawString(prefix)
		out.String(string(in.ConsensusHash))
	}
	{
		const prefix string = ",\"app_hash\":"
		out.RawString(prefix)
		out.String(string(in.AppHash))
	}
	{
		const prefix string = ",\"last_results_hash\":"
		out.RawString(prefix)
		out.String(string(in.LastResultsHash))
	}
	{
		const prefix string = ",\"evidence_hash\":"
		out.RawString(prefix)
		out.String(string(in.EvidenceHash))
	}
	{
		const prefix string = ",\"proposer_address\":"
		out.RawString(prefix)
		out.String(string(in.ProposerAddress))
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode8(in *jlexer.Lexer, out *struct {
	Block string `json:"block"`
	App   string `json:"app"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "block":
			out.Block = string(in.String())
		case "app":
			out.App = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode8(out *jwriter.Writer, in struct {
	Block string `json:"block"`
	App   string `json:"app"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"block\":"
		out.RawString(prefix[1:])
		out.String(string(in.Block))
	}
	{
		const prefix string = ",\"app\":"
		out.RawString(prefix)
		out.String(string(in.App))
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode(in *jlexer.Lexer, out *struct {
	Hash          string `json:"hash"`
	PartSetHeader struct {
		Total int    `json:"total"`
		Hash  string `json:"hash"`
	} `json:"part_set_header"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "hash":
			out.Hash = string(in.String())
		case "part_set_header":
			easyjson31c5d66Decode9(in, &out.PartSetHeader)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode(out *jwriter.Writer, in struct {
	Hash          string `json:"hash"`
	PartSetHeader struct {
		Total int    `json:"total"`
		Hash  string `json:"hash"`
	} `json:"part_set_header"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"hash\":"
		out.RawString(prefix[1:])
		out.String(string(in.Hash))
	}
	{
		const prefix string = ",\"part_set_header\":"
		out.RawString(prefix)
		easyjson31c5d66Encode9(out, in.PartSetHeader)
	}
	out.RawByte('}')
}
func easyjson31c5d66Decode9(in *jlexer.Lexer, out *struct {
	Total int    `json:"total"`
	Hash  string `json:"hash"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "total":
			out.Total = int(in.Int())
		case "hash":
			out.Hash = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson31c5d66Encode9(out *jwriter.Writer, in struct {
	Total int    `json:"total"`
	Hash  string `json:"hash"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"total\":"
		out.RawString(prefix[1:])
		out.Int(int(in.Total))
	}
	{
		const prefix string = ",\"hash\":"
		out.RawString(prefix)
		out.String(string(in.Hash))
	}
	out.RawByte('}')
}

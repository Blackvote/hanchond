// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package web3

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb3(in *jlexer.Lexer, out *TxReceiptResult) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "blockHash":
			out.BlockHash = string(in.String())
		case "blockNumber":
			out.BlockNumber = string(in.String())
		case "contractAddress":
			out.ContractAddress = string(in.String())
		case "cumulativeGasUsed":
			out.CumulativeGasUsed = string(in.String())
		case "from":
			out.From = string(in.String())
		case "gasUsed":
			out.GasUsed = string(in.String())
		case "logs":
			if in.IsNull() {
				in.Skip()
				out.Logs = nil
			} else {
				in.Delim('[')
				if out.Logs == nil {
					if !in.IsDelim(']') {
						out.Logs = make([]struct {
							Address          string   `json:"address"`
							Topics           []string `json:"topics"`
							Data             string   `json:"data"`
							BlockNumber      string   `json:"blockNumber"`
							TransactionHash  string   `json:"transactionHash"`
							TransactionIndex string   `json:"transactionIndex"`
							BlockHash        string   `json:"blockHash"`
							LogIndex         string   `json:"logIndex"`
							Removed          bool     `json:"removed"`
						}, 0, 0)
					} else {
						out.Logs = []struct {
							Address          string   `json:"address"`
							Topics           []string `json:"topics"`
							Data             string   `json:"data"`
							BlockNumber      string   `json:"blockNumber"`
							TransactionHash  string   `json:"transactionHash"`
							TransactionIndex string   `json:"transactionIndex"`
							BlockHash        string   `json:"blockHash"`
							LogIndex         string   `json:"logIndex"`
							Removed          bool     `json:"removed"`
						}{}
					}
				} else {
					out.Logs = (out.Logs)[:0]
				}
				for !in.IsDelim(']') {
					var v1 struct {
						Address          string   `json:"address"`
						Topics           []string `json:"topics"`
						Data             string   `json:"data"`
						BlockNumber      string   `json:"blockNumber"`
						TransactionHash  string   `json:"transactionHash"`
						TransactionIndex string   `json:"transactionIndex"`
						BlockHash        string   `json:"blockHash"`
						LogIndex         string   `json:"logIndex"`
						Removed          bool     `json:"removed"`
					}
					easyjsonF8541ff4Decode(in, &v1)
					out.Logs = append(out.Logs, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "logsBloom":
			out.LogsBloom = string(in.String())
		case "status":
			out.Status = string(in.String())
		case "to":
			out.To = string(in.String())
		case "transactionHash":
			out.TransactionHash = string(in.String())
		case "transactionIndex":
			out.TransactionIndex = string(in.String())
		case "type":
			out.Type = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb3(out *jwriter.Writer, in TxReceiptResult) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"blockHash\":"
		out.RawString(prefix[1:])
		out.String(string(in.BlockHash))
	}
	{
		const prefix string = ",\"blockNumber\":"
		out.RawString(prefix)
		out.String(string(in.BlockNumber))
	}
	{
		const prefix string = ",\"contractAddress\":"
		out.RawString(prefix)
		out.String(string(in.ContractAddress))
	}
	{
		const prefix string = ",\"cumulativeGasUsed\":"
		out.RawString(prefix)
		out.String(string(in.CumulativeGasUsed))
	}
	{
		const prefix string = ",\"from\":"
		out.RawString(prefix)
		out.String(string(in.From))
	}
	{
		const prefix string = ",\"gasUsed\":"
		out.RawString(prefix)
		out.String(string(in.GasUsed))
	}
	{
		const prefix string = ",\"logs\":"
		out.RawString(prefix)
		if in.Logs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Logs {
				if v2 > 0 {
					out.RawByte(',')
				}
				easyjsonF8541ff4Encode(out, v3)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"logsBloom\":"
		out.RawString(prefix)
		out.String(string(in.LogsBloom))
	}
	{
		const prefix string = ",\"status\":"
		out.RawString(prefix)
		out.String(string(in.Status))
	}
	{
		const prefix string = ",\"to\":"
		out.RawString(prefix)
		out.String(string(in.To))
	}
	{
		const prefix string = ",\"transactionHash\":"
		out.RawString(prefix)
		out.String(string(in.TransactionHash))
	}
	{
		const prefix string = ",\"transactionIndex\":"
		out.RawString(prefix)
		out.String(string(in.TransactionIndex))
	}
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TxReceiptResult) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TxReceiptResult) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TxReceiptResult) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TxReceiptResult) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb3(l, v)
}
func easyjsonF8541ff4Decode(in *jlexer.Lexer, out *struct {
	Address          string   `json:"address"`
	Topics           []string `json:"topics"`
	Data             string   `json:"data"`
	BlockNumber      string   `json:"blockNumber"`
	TransactionHash  string   `json:"transactionHash"`
	TransactionIndex string   `json:"transactionIndex"`
	BlockHash        string   `json:"blockHash"`
	LogIndex         string   `json:"logIndex"`
	Removed          bool     `json:"removed"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "address":
			out.Address = string(in.String())
		case "topics":
			if in.IsNull() {
				in.Skip()
				out.Topics = nil
			} else {
				in.Delim('[')
				if out.Topics == nil {
					if !in.IsDelim(']') {
						out.Topics = make([]string, 0, 4)
					} else {
						out.Topics = []string{}
					}
				} else {
					out.Topics = (out.Topics)[:0]
				}
				for !in.IsDelim(']') {
					var v4 string
					v4 = string(in.String())
					out.Topics = append(out.Topics, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "data":
			out.Data = string(in.String())
		case "blockNumber":
			out.BlockNumber = string(in.String())
		case "transactionHash":
			out.TransactionHash = string(in.String())
		case "transactionIndex":
			out.TransactionIndex = string(in.String())
		case "blockHash":
			out.BlockHash = string(in.String())
		case "logIndex":
			out.LogIndex = string(in.String())
		case "removed":
			out.Removed = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonF8541ff4Encode(out *jwriter.Writer, in struct {
	Address          string   `json:"address"`
	Topics           []string `json:"topics"`
	Data             string   `json:"data"`
	BlockNumber      string   `json:"blockNumber"`
	TransactionHash  string   `json:"transactionHash"`
	TransactionIndex string   `json:"transactionIndex"`
	BlockHash        string   `json:"blockHash"`
	LogIndex         string   `json:"logIndex"`
	Removed          bool     `json:"removed"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"address\":"
		out.RawString(prefix[1:])
		out.String(string(in.Address))
	}
	{
		const prefix string = ",\"topics\":"
		out.RawString(prefix)
		if in.Topics == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v5, v6 := range in.Topics {
				if v5 > 0 {
					out.RawByte(',')
				}
				out.String(string(v6))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"data\":"
		out.RawString(prefix)
		out.String(string(in.Data))
	}
	{
		const prefix string = ",\"blockNumber\":"
		out.RawString(prefix)
		out.String(string(in.BlockNumber))
	}
	{
		const prefix string = ",\"transactionHash\":"
		out.RawString(prefix)
		out.String(string(in.TransactionHash))
	}
	{
		const prefix string = ",\"transactionIndex\":"
		out.RawString(prefix)
		out.String(string(in.TransactionIndex))
	}
	{
		const prefix string = ",\"blockHash\":"
		out.RawString(prefix)
		out.String(string(in.BlockHash))
	}
	{
		const prefix string = ",\"logIndex\":"
		out.RawString(prefix)
		out.String(string(in.LogIndex))
	}
	{
		const prefix string = ",\"removed\":"
		out.RawString(prefix)
		out.Bool(bool(in.Removed))
	}
	out.RawByte('}')
}
func easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb31(in *jlexer.Lexer, out *TxReceipt) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "jsonrpc":
			out.Jsonrpc = string(in.String())
		case "id":
			out.ID = int(in.Int())
		case "result":
			(out.Result).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb31(out *jwriter.Writer, in TxReceipt) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"jsonrpc\":"
		out.RawString(prefix[1:])
		out.String(string(in.Jsonrpc))
	}
	{
		const prefix string = ",\"id\":"
		out.RawString(prefix)
		out.Int(int(in.ID))
	}
	{
		const prefix string = ",\"result\":"
		out.RawString(prefix)
		(in.Result).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TxReceipt) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb31(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TxReceipt) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonF8541ff4EncodeGithubComHanchonHanchondLibTypesWeb31(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TxReceipt) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb31(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TxReceipt) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonF8541ff4DecodeGithubComHanchonHanchondLibTypesWeb31(l, v)
}
